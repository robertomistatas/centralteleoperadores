import{a as m,s as c,b as d,d as l,c as s,g as w,q as U,e as g,w as A,f as p}from"./index-DVV4dsKx.js";class f{constructor(){this.collection="userProfiles",this.pendingUsersCollection="pendingUsers"}async createUserIntelligent(e){var t;try{console.log("ðŸ§  Iniciando creaciÃ³n inteligente de usuario:",e.email);const{email:i,displayName:r,role:n="teleoperadora",isActive:h=!0}=e,o=i.toLowerCase().trim();if(await this.getUserByEmail(o))throw new Error(`Usuario con email ${o} ya existe`);const a=this.generatePredictiveUID(o),u={uid:a,email:o,displayName:r.trim(),role:n,isActive:h,createdAt:c(),updatedAt:c(),createdBy:((t=m.currentUser)==null?void 0:t.uid)||"system",authenticationStatus:"pending",profileType:"smart_created",smartSync:{enabled:!0,emailNormalized:o,createdViaApp:!0,waitingForAuth:!0}};await d(l(s,this.collection,a),u),console.log("âœ… Perfil creado en Firestore con UID predictivo:",a);const y={email:o,displayName:r.trim(),role:n,predictiveUID:a,createdAt:c(),status:"waiting_auth_registration"};return await d(l(s,this.pendingUsersCollection,a),y),console.log("âœ… Usuario agregado a lista de pendientes"),this.setupAuthDetectionListener(o,a),await this.updatePermissionsLogic(o,n),{success:!0,uid:a,profile:u,message:`Usuario ${r} creado exitosamente. Cuando se registre con ${o}, serÃ¡ reconocido automÃ¡ticamente.`}}catch(i){throw console.error("âŒ Error en creaciÃ³n inteligente:",i),i}}generatePredictiveUID(e){const t=Date.now();return`smart_${btoa(e).replace(/[^a-zA-Z0-9]/g,"").substring(0,8)}_${t}`}setupAuthDetectionListener(e,t){console.log("ðŸ‘‚ Configurando listener para detectar registro de:",e),m.onAuthStateChanged(async i=>{var r;i&&((r=i.email)==null?void 0:r.toLowerCase())===e&&(console.log("ðŸŽ¯ Usuario detectado en Auth:",i.email),await this.syncWithAuthRegistration(i,t))})}async syncWithAuthRegistration(e,t){try{console.log("ðŸ”„ Sincronizando usuario con Auth:",e.email);const i=await w(l(s,this.collection,t));if(i.exists()){const r=i.data(),n={...r,uid:e.uid,displayName:e.displayName||r.displayName,authenticationStatus:"authenticated",syncedAt:c(),smartSync:{...r.smartSync,waitingForAuth:!1,syncedWithAuth:!0,originalPredictiveUID:t}};await d(l(s,this.collection,e.uid),n),console.log("âœ… Perfil sincronizado con UID real:",e.uid),await this.cleanupPendingUser(t),console.log("ðŸŽ‰ SincronizaciÃ³n completada exitosamente")}}catch(i){console.error("âŒ Error en sincronizaciÃ³n:",i)}}async cleanupPendingUser(e){try{await d(l(s,this.pendingUsersCollection,e),{status:"completed",completedAt:c()},{merge:!0})}catch(t){console.error("Error limpiando usuario pendiente:",t)}}async updatePermissionsLogic(e,t){console.log("ðŸ”§ Actualizando lÃ³gica de permisos para:",e,"con rol:",t)}async getUserByEmail(e){try{const t=U(g(s,this.collection),A("email","==",e.toLowerCase().trim())),i=await p(t);if(!i.empty){const r=i.docs[0];return{id:r.id,...r.data()}}return null}catch(t){return console.error("Error obteniendo usuario por email:",t),null}}async getPendingUsers(){try{return(await p(g(s,this.pendingUsersCollection))).docs.map(t=>({id:t.id,...t.data()}))}catch(e){return console.error("Error obteniendo usuarios pendientes:",e),[]}}}const D=new f;export{D as default,D as smartUserCreationService};
